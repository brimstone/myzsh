# our precmd runs first, as it build up the PROMPT variable
function precmd_main {
	###
	# Decide whether to set a screen title
	if [ -n "$STY" -o -n "$TMUX" ]; then
		TITLEOUTPUT=""
		for ((i=1; i <= ${#title_funcs}; i+=1)); do
			$title_funcs[$i] | read -r OUTPUT
			[ -n "$OUTPUT" ] && TITLEOUTPUT+="${OUTPUT}:"
		done
		printf "\x1bk%s\x1b\\" "${TITLEOUTPUT%:}"
	fi
	# Now that we have all of our variables set, let our theme compute its prompt
	theme_prompt
}

function precmd {
	# Capture our exit code
	local exitcode=$?
	# run all of our precmd functions setup for us
	local i
	for ((i=1; i <= ${#precmd_funcs}; i+=1)); do
		$precmd_funcs[$i]
	done
}

function preexec {
	# run all of our preexec functions
	# this is off by 1 because preexec_funcs is initalized with nothing
	local i
	for ((i=1; i <= ${#preexec_funcs}; i+=1)); do
		$preexec_funcs[$i] "$1"
	done
}

function myzsh {
	verb="$1"
	mod="$2"

	# edit a module
	if [ "$verb" = "edit" ]; then
		[ ! -e "$BASE/modules/$mod/$mod" ] && echo "Cannot find module $mod" && return 1
		$EDITOR "$BASE/modules/$mod/$mod"
	# reload a specific module's functions
	elif [ "$verb" = "reload" ]; then
		[ ! -e "$BASE/modules/$mod/$mod" ] && echo "Cannot find module $mod" && return 1
		source "$BASE/modules/$mod/$mod"
	# update all of myzsh
	elif [ "$verb" = "update" ]; then
		# Update via svn, if we can
		if svn info $BASE 2>/dev/null >/dev/null; then
			svn up $BASE
		# TODO elif git something
		fi
	# list info about all modules
	elif [ "$verb" = "list" ]; then
		(
		# This is inside a code block so cd is ok
		cd "$BASE/modules" >/dev/null
		local m
		# this is a hack to find the length of the longest module name
		max=$(for m in *; do
			[ ! -f "$m/$m" ] && continue
			echo ${#m}
		done | sort -n | tail -n 1);
		# dump them to the screen
		printf "%${max}s: %-13s %s\n" "Module" "Enabled" "Description"
		for m in *; do
			[ ! -f "$m/$m" ] && continue
			# figure out where our module is enabled, if at all
			enabled="$(
				for x in "${LPRIMARY[@]}"; do
					[ "$x" = "$m" ] && printf "LP "
				done
				for x in "${LSECONDARY[@]}"; do
					[ "$x" = "$m" ] && printf "LS "
				done
				for x in "${RPRIMARY[@]}"; do
					[ "$x" = "$m" ] && printf "RP "
				done
				for x in "${RSECONDARY[@]}"; do
					[ "$x" = "$m" ] && printf "RS "
				done
				for x in "${EXTRA[@]}"; do
					[ "$x" = "$m" ] && printf "E "
				done
			)"
			printf "%${max}s: %-13s %s\n" "$m" "$enabled" "$(awk '/^\#+\ ?Summary/ {getline; print $0}' $m/info.md 2>/dev/null)"
		done | sort;
		)
	# get info about a module
	elif [ "$verb" = "info" ]; then
		[ ! -e "$BASE/modules/$mod/$mod" ] && echo "Cannot find module $mod" && return 1
		less "$BASE/modules/$mod/info.md"
	# test a module
	# TODO needs plenty more work
	elif [ "$verb" = "test" ]; then
		[ ! -e "$BASE/modules/$mod/$mod" ] && echo "Cannot find module $mod" && return 1
		# setup a sub shell so we don't mess up our main environment since this is a function
		(
		function getvars() {
			set | sed '/^LINENO/d;/^ERRNO/d;/^-=/d'
		}
		SHELL=/dev/null
		cd "$BASE/modules"
		getvars > /tmp/set.before
		source "$mod/$mod"
		getvars > /tmp/set.after

		echo "== Variables changed during init =="
		diff -au /tmp/set.before /tmp/set.after | sed '/^ /d;/^@/d;/^+++/d;/^---/d'
		if [ -n "$OUTPUT" ]; then
			echo "== Errors while running output function =="
			getvars > /tmp/set.before
			$OUTPUT |read -r $out
			getvars > /tmp/set.after
			echo "== Variables changed after running output function =="
			diff -au /tmp/set.before /tmp/set.after | sed '/^ /d;/^@/d;/^+++/d;/^---/d'
			echo "== Output from output function =="
			echo "[$out]"
		fi
		rm /tmp/set.before /tmp/set.after
		)
	fi
}

# basic system detection
function islinux {
	[ $(uname) = "Linux" ]
}

function isosx {
	[ $(uname) = "Darwin" ]
}

# first Set any variables
preexec_funcs=()
precmd_funcs=(precmd_main)
# then load the theme
# check for theme, select our default if nothing's set
[ ! -e "$BASE/themes/$THEME/$THEME" ] && THEME="default"
source "$BASE/themes/$THEME/$THEME"
# set other globals
[ -z "$EDITOR" ] && export EDITOR=vim && bindkey -e

# Load any one time modules
for m in $EXTRA; do
	OUTPUT=""
	myzsh reload "$m"
done


lp_funcs=()
for m in $LPRIMARY; do
	OUTPUT=""
	myzsh reload "$m" && lp_funcs+=($OUTPUT)
done
# Figure out our left secondary output
ls_funcs=()
for m in $LSECONDARY; do
	OUTPUT=""
	myzsh reload "$m" && ls_funcs+=($OUTPUT)
done
# Figure out our right primary output
rp_funcs=()
for m in $RPRIMARY; do
	OUTPUT=""
	myzsh reload "$m" && rp_funcs+=($OUTPUT)
done
# Figure out our right secondary output
rs_funcs=()
for m in $RSECONDARY; do
	OUTPUT=""
	myzsh reload "$m" && rs_funcs+=($OUTPUT)
done

# Figure out our title output
title_funcs=()
for m in $TITLE; do
	OUTPUT=""
	myzsh reload "$m" && title_funcs+=($OUTPUT)
done

# TODO make sure our completion stuff is loaded so this works
# our completion should be loaded by now so we can link our completion function to our management function
compdef _myzsh myzsh

# alert the user if our shell doesn't look like zsh
if [[ "$SHELL" =~ "/zsh" ]]; then
	echo "zsh may not be your shell."
	echo "Run 'myzsh persistant' to set zsh as your shell."
	echo
fi
if [ ! -e "$HOME/.zshrc" ]; then
	echo "You don't seem to have a .zshrc config file."
	echo "Run 'myzsh save' to save a default .zshrc file."
	echo
fi

# vim: filetype=zsh tabstop=4 softtabstop=4 shiftwidth=4 noexpandtab
